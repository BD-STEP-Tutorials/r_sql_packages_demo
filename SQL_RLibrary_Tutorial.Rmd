---
title: "R Database Presentation"
author: "Trevor Michelson"
date: "2023-09-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
Connecting to and working with SQL databases in R generally requires two packages, **odbc** and 
**DBI**. The **dbplyr** is designed to help interface with and mimic SQL queries, which can be
a very convenient way to work with a SQL database even if you are familiar with R but not SQL. 
```{r message=FALSE, warning=FALSE}
library(DBI) # Basic database infrastucture for R, let's R talk to other databases (MS SQL, MySQL, Oracle, Etc.)
#library(RODBC) # Pre-dates the odbc package, but not compliant with DBI and is no longer in active development
#library(VINCI)
library(odbc) # Implements DBI's methods for ODBC connections, which MS SQL uses
library(dbplyr) # implements the specifics of the dplyr operations for remote SQL table
library(tidyverse)
library(duckdb)
``` 

## Making the Connection
``` {r message=FALSE, warning=FALSE}
# Manually Create the Connection
setwd('/workspaces/R_SQL_Demo/database')
con <- dbConnect(RSQLite::SQLite(), "synthetic.db", timeout = 10)
```
Can use the Connections tab
![new connection screenshot](H:/Pictures/Capture.png)

Can use the VINCI Library - broken as of 10/3/2023

## Opposite tools
R is great at complicated algorithms for plotting, fitting models, and general data analysis. Not too great at managing
big datasets.

SQL is great at managing big datasets. Not too great at complicated algorithms for plotting, fitting models, and 
general data analysis. 

Therefore, you want to filter the big data as much as possible before you bring it into R.0

## Method 1: Write a SQL statement and execute it in RStudio
This method works best if you already know how to write SQL queries and are working in an RMarkdown file.

Create a new RMarkdown chunk, but change its heading to '{sql, connection = con, output.var = "Results_Table"}' 
instead of the default '{r}'
``` {sql, connection = con, output.var = "PATIENT_COHORT_1", warning=FALSE}
SELECT 
  patient.patient, patient.birthdate, patient.race, patient.ethnicity, patient.gender, encounter.DESCRIPTION as encounter_description, encounter.REASONDESCRIPTION as notes, encounter.DATE as encounter_date
FROM 
   [synthetic.patients] as patient
LEFT JOIN
   [synthetic.encounters] as encounter ON encounter.PATIENT = patient.patient
WHERE 
   patient.gender like 'M' and encounter.DATE >= '2015-01-01' 
```

RStudio can natively read SQL script when it's in a markdown chunk set to '{sql}'.
'output.var' sets the name of the data frame to store the results in, which we've called
'Temp_Table'. The text is the SQL script required to retrieve and filter the data from the 
table(s) in our database.

You can now work with this data like you would with any other data frame.

``` {r message=FALSE, warning=FALSE}
head(PATIENT_COHORT_1)
```

## Method 2:
You're not always able to write a SQL statement in a dedicated chunk. For instance, you might be looping 
through some data and need to execute a SQL query based on a variable value. This means you'd need to 
programmatically change the SQL query, which is best done with the R script. 

Though not required for this example we'll demo how to build the SQL query in multiple pieces and then
join them together as a single piece of text. This will allow us to loop through and modify the method
if you're making use of loops or other R objects. 
```{r message=FALSE, warning=FALSE}
select <- "SELECT patient.patient, patient.birthdate, patient.race, patient.ethnicity, patient.gender,
encounter.DESCRIPTION as encounter_description, encounter.REASONDESCRIPTION as notes, encounter.DATE as encounter_date"
from <- "FROM [synthetic.patients] as patient"
ljoin <- "LEFT JOIN [synthetic.encounters] as encounter ON encounter.PATIENT = patient.patient"
where <- "WHERE patient.gender like 'M' and encounter.DATE >= '2015-01-01'"

query <- paste(select, from, ljoin, where)

PATIENT_COHORT_2a <- DBI::dbGetQuery(conn = con,
                                 statement = query)

head(PATIENT_COHORT_2a)
```

```{r message=FALSE, warning=FALSE}
patient_encounter_by_year_gender <- function(gender, date) {
  select <- "SELECT patient.patient, patient.birthdate, patient.race, patient.ethnicity, patient.gender,
  encounter.DESCRIPTION as encounter_description, encounter.REASONDESCRIPTION as notes, encounter.DATE as encounter_date"
  from <- "FROM [synthetic.patients] as patient"
  ljoin <- "LEFT JOIN [synthetic.encounters] as encounter ON encounter.PATIENT = patient.patient"
  where <- paste0("WHERE patient.gender like '", gender, "' AND encounter.DATE >= '", data,"'")

  query <- paste(select, from, ljoin, where)
  
  df <- DBI::dbGetQuery(conn = con,
                        statement = query)
  
  return(df)
}

PATIENT_COHORT_2b <- patient_encounter_by_year_gender('M', '2015-01-01')
head(PATIENT_COHORT_2b)
```

## Method 3
This method is the easiest for those who are comfortable working with the dplyr and tidyverse functions but
not yet familiar with SQL Scripting. The dplyr package was actually designed to replicate the most common SQL commands,
so you may find it easy to learn the SQL-equivalent of dplyr functions. 

```{r}
OMOP_COHORT_3 <- 
  tbl(src = con, from = "synthetic.patients") %>%
  filter(gender == 'M') %>%
  select(patient, birthdate, race, ethnicity, gender) 

```